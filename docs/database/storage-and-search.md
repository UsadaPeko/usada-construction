# DDIA 3장 - 저장소와 검색
데이터베이스에서는 파일에 데이터들을 저장함

가장 간단한 방법은 로그처럼 파일 끝에 계속해서 변경된 값을 추가하는 방식
하지만 이렇게되면 특정 데이터를 찾는데 너무 오랜 시간이 걸림

Hash 색인이라고, 특정 Key로만 데이터를 찾을 때는 인메모리 해시맵을 사용하기도 함.
-> 그러면 메모리에 제약이 생기기도 함.

데이터를 계속해서 추가하다보면 파일이 너무 커짐
기본적으로 데이터는 순차적으로 추가하는게 제일 효율적인데, 따라서 필요없는 데이터가 쌓이기도 함.

세그먼트로 페이지를 나누어서 저장
-> 직접 지우거나, 병합시켜서 정리해줄 수 있음

해시 색인 자체에서 오는 단점도 존재함. range 조회에 매우 취약함
where절같은거 redis는 사용 못하고, Dynamo도 이렇게 안쓰는걸 권장함. (사실 MySQL에서도 OLAP가 아니면 굳이...?)

## SS테이블
-> 세그먼트에서 key들을 정렬한 것
정렬되어있으니 모든 key의 위치를 메모리에 들고있지 않아도 괜찮음
-> 어차피 조금 더 찾아보면 되니까

정렬된 것을 어떻게 유지할건지?
-> AVL Tree를  사용해서 해결
그리고 열심히 정렬..

메모리에 있는 AVL Tree -> 파일로 저장

SS Table로 LSM트리 만들 수 있음
SS Table을 지속적으로 병합해서 만들어짐

## B Tree
일반적인 RDS에서는 B Tree를 사용함
-> 여러가지 개선 버전이 존재함

B Tree는 인덱스를 기준으로 색인함
어느정도 깊이를 자동으로 맞춰주는 친구

B Tree는 색인하는 범위를 고정한다. SS Table은 가변 길이.
B Tree는 기존에 데이터를 덮어쓰는걸 기본동작으로 실행한다

## 비교

(보통 경험적으로) LSM Tree는 읽기에서 빠르고, B Tree는 쓰기에서 빠르다
LSM Tree는 여러 세그먼트를 뒤져야해서...

LSM Tree는 압축률 좋음. 놀고잇는 공간 없음. B Tree는 범위를 유지해야해서 노는 공간 생김

LSM Tree는 덮어쓰지 않기때문에 자기 테이프에서 쓰기 성능이 좋음

LSM Tree는 컴팩션이 있으면 느려질 수 있음. 평균은 빠른데 가끔 많이 느려질수도..
B Tree는 어느정도 일관된 성능을 내줌

데이터가 많아지고 컴팩션 많아지면 더 부하가 됨..

B Tree는 색인이 한곳에서만 정확하게 존재함. LSM Tree는 여러 세그먼트 뒤져야함
그래서 B Tree는 트랜잭션 만들기 좋음.

## Secondary Index
정규화한거랑 비슷함

다이나모에서 써본적 있음

## Memory 저장
레디스같이 모든걸 메모리에 저장하는 경우도 늘어나고 있음

비동기로 파일에 저장하는 약한 지속성으로 보장하기도함

## 트랜잭션이나 분석
OLAP vs OLTP

느낌만 설명하자면, 분석은 OLAP, 단순한 조회는 OLTP

Data warehouse -> 데이터 분석을 위한 것
ETL로 표현되는 작업들을 통해서 웨어 하우스에 데이터를 적재

OLAP는 컬럼러 데이터베이스를 차용하는 경우도 많음 -> redshift
많은 데이터로 복잡한 조회할 때 빠르더라

예를들어 최근3년, 한달에 방문한 유니크 유저는? 
예를들어 최근2달, 처음 방문한 유저가 바로 구매까지 이어진 횟수와 아닌 횟수는?

