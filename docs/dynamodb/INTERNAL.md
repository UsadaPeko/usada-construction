# DDB INTERNAL

DynamoDB는 분산 저장소입니다. 그 내부 동작을 설명합니다.

From: https://www.allthingsdistributed.com/2007/10/amazons_dynamo.html

## 시스템 가정 및 요구 사항

DynamoDB에 대한 가정과 요구사항은 다음과 같습니다.

쿼리 모델 : 키로 고유하게 식별되는 데이터에 대한 간단한 읽기 및 쓰기 작업입니다. 상태는 고유 키로 식별되는 바이너리로 저장됩니다. 작업이 여러 데이터에 걸쳐 있지 않으며 관계형 스키마가 필요하지 않습니다. 이 요구 사항은 Amazon 서비스의 상당 부분이 이 간단한 쿼리 모델로 작동할 수 있으며 관계형 스키마가 필요하지 않다는 것을 기반으로 합니다. Dynamo는 비교적 작은(일반적으로 1MB 미만) 객체를 저장해야 하는 애플리케이션을 대상으로 합니다.

ACID 속성: ACID (Atomicity, Consistency, Isolation, Durability)는 데이터베이스의 트랜잭션이 안정적으로 처리되는 것을 보장하는 방법입니다. 데이터베이스 컨텍스트에서 데이터에 대한 단일 논리 작업을 트랜잭션이라고 합니다. Amazon의 경험에 따르면 ACID 보장을 제공하는 데이터 저장소는 가용성이 떨어지는 경향이 있습니다. 이는 업계와 학계에서 널리 인정받고 있습니다[5]. Dynamo는 일관성(ACID의 "C")을 일부 포기하여 고가용성을 달성합니다. Dynamo는 어떤 isolation(격리)을 제공하지 않으며 단일 키 업데이트만 허용합니다.

TBD

## 설계 고려사항

프로덕션 시스템에서 사용되는 데이터 복제 알고리즘은 Strong Consistant한 데이터 액세스 인터페이스를 제공하기 위해 예전부터 동기로 복제를 실행하고 있었습니다(synchronous replication). dynamo db가 목표한 consistency를 달성하기 위해 이러한 알고리즘은 특정 오류 시나리오에서 데이터 가용성을 희생해야합니다. 예를 들어, 답변의 정확성에 대한 불확실성을 다루기보다 데이터가 정확하다는 것이 절대적으로 확신될 때까지 데이터를 사용할 수 없게 됩니다. 초창기 데이터베이스 Replication에 관한 연구에서 확인할 수 있다시피, 네트워크 장애 가능성을 처리할 때 강력한 일관성과 높은 데이터 가용성을 동시에 달성할 수 없다는 것은 잘 알려져 있습니다[2, 11]. 이런 시스템과 응용 프로그램은 어떤 조건에서 어떤 속성을 달성할 수 있는지 알아야 합니다.

서버 및 네트워크 오류가 발생하기 쉬운 시스템의 경우, availability의 경우 사항이 백그라운드에서 레플리카로 전파되도록 허용하고 연결이 끊긴 동시 작업이 허용되는 optimistic replication를 이용해서 향상시킬 수 있습니다. 이 접근 방식의 문제는 감지하고 해결해야 하는 conflict change로 이어질 수 있다는 것입니다. 이러한 conflict resolution 프로세스는 두 가지 문제를 야기합니다. 누가, 언제 conflict를 해결하는지입니다. DynamoDB는 eventually consistent한 데이터 저장소로 설계되었습니다. 모든 업데이트는 결국 모든 레플리카에 도달합니다.

중요한 설계 고려사항 중 하나는 conflict된 update 해결 프로세스를 실행할 시점입니다. (i.e. 읽기 또는 쓰기 중에 충돌을 해결해야하는지 여부) 많은 전통적인 데이터 저장도는 conflict resolution을 쓰는 시점에 실행하고, 읽는 시간(complexity)을 짧게 유지합니다[7]. 이러한 시스템에서 쓰는 동작은 데이터 저장소가 모든 Replica에 데이터를 복제하지 못했다면 아마도 거부(rejected)될 수 있습니다. 하지만 DynamoDB는 항상 쓸 수 있는 데이터 저장소를 목표로합니다. (i.e. write에 고가용성인 데이터 스토어) 많은 아마존의 서비스에서, 고객의 update를 거부한다면 고객 경험을 해칠 것 입니다. 예를 들어, 쇼핑카트 서비스는 네트워크 및 서버 장애가 발생해도 고객이 항목을 추가 및 제거를 할 수 있어야합니다.

그 다음 설계 고려사항은 conflict resolution을 수행하는 주체입니다. 수행하는 주체는 데이터 스토어나 어플리케이션이 될 수 있습니다. 만약 데이터 스토어에서 conflict resolution를 수행한다면 선택 사항이 조금 제한됩니다. 이러한 케이스에서 데이터 스토어는 update conflict를 해결하기 위해 "마지막에 write가 이긴다[22]"와 같은 간단한 정책만 사용할 수 있습니다. 한편으로, 데이터 스키마를 알고 있는 어플리케이션은  고객의 경험을 위해 가장 적절한 conflict resolution 방법을 결정할 수 있습니다. 예를 들어, 고객 장바구니를 관리하는 애플리케이션은 conflict된 버전을 "병합-merge"하고 하나로 합쳐진 장바구니를 반환하도록 선택할 수 있습니다. 이러한 유연성에도 불구하고 일부 어플리케이션 개발자는 자체 conflict resolution 메커니즘을 작성하기를 원하지 않고 데이터 저장소에 그냥 저장합니다. 그러면 데이터 저장소는 "마지막 쓰기 승리"와 같은 간단한 정책을 선택할 수 밖에 없습니다.

TBD

## 가용성과 확정성의 핵심 - 해싱과 

TBD
