# DynamoDB

DynamoDB는 NoSQL의 한 종류입니다. AWS에서 사용할 수 있습니다.

## 언제 사용하나?

key / value로 값을 저장하고 찾을 수 있는 경우 사용합니다. DDB(DynamoDB)는 분산된 형태로 동작하기 때문에 비슷한 종류인 Redis보다 더 많은 트래픽을 처리할 수 있습니다.

주로 Read가 많으며 Write가 적은 경우 사용합니다.

## 사용하면 안되는 시점

hash key(paritition key)를 설정하기 힘들거나, Write가 많은 경우에는 적절하지 않을 수 있습니다. 또한 복잡한 쿼리가 요구되는 상황에서도 부적절합니다.

### 왜 Hash Key를 설정하는게 중요한가

DDB는 hash key로 파티션을 나누게 됩니다. 만약 한 파티션에 요청이 몰리는 핫 파티션 문제가 발생한다면 비용이 높게 발생하게 됩니다.

DDB의 설계를 잘하기 위하여 파티션 별로 적절히 트래픽이 분산되는게 꼭 필요합니다.

See Also
  - https://docs.aws.amazon.com/ko_kr/amazondynamodb/latest/developerguide/bp-partition-key-design.html#bp-partition-key-partitions-adaptive-boost

### Write가 많은 상태에서의 DDB

Write가 Read에 비하여 비용이 비싸며, 시간이 오래걸립니다.

### 복잡한 쿼리 만들기

DDB는 기본적으로 데이터를 Hash Key, Sort Key로 찾을 수 있습니다. 만약 조건이 복잡하다면, DDB의 성능이 나빠지거나 비용이 많이 나올 수 있습니다. 혹시나 3~4개 이상의 조건으로 아이템을 찾아야 한다면 다른 방법을 고려하는게 좋습니다.

물론 Index를 추가적으로 사용할 수도 있지만, 제한적입니다.

## 사용하면 좋은 시점

성능이 필요하며, 복잡한 쿼리가 아닐 때. 비교적 작은 객체를 저장하는 경우

### 실제 사례 1

개발중이던 서비스에는 유저들의 click 기록을 저장하고, 최근에 클릭한 것을 나중에 보여주는 기능이 있었습니다. (일종의 추천시스템이에요) 운좋게도 서비스는 점점 성장해갔습니다. 이전에는 초당 1개의 요청만 처리하면 되지만, 이제는 초당 100개의 요청을 견뎌야하는거죠. 게다가 유저들의 Click 기록 양이 늘어나면서 데이터는 점점 많아져갔습니다.

기존 서비스는 MySQL로 이루어져 있었습니다. 그리고 Click 데이터는 User의 ID로만 가져오고있었죠. 이 상황에서 MySQL의 테이블에는 계속 부하가 걸렸습니다. 물론 쿼리를 수정하는 방법도 있었지만 저는 빠르게 DynamoDB로 전환하였습니다.

우리 팀은 빠르게 DynamoDB로 시스템을 변경하였고, 기존에 p95에서 1.5s 정도 걸리던 Latency가 100ms이하로 줄어들게 되었습니다. 이때 파티션 key를 유저의 ID로 하였고, sort key를 Item ID로 두었습니다. 이렇게 빠르게 유저가 클릭한 Item들을 가져올 수 있게 되었죠.

MySQL의 데이터를 옮기는 과정은 과감히 생략하였습니다. 빠르게 성능이 개선되는걸 보고싶었으며, 기존의 클릭 기록이 초기화 되는게 크게 문제가 없다고 생각했어요. 아직 서비스가 본격적으로 날개를 펴는 과정이라서 가능한 선택이었습니다.

### 실제 사례 2

서비스는 점점 더 성장해서 아주 중요한 상태가 되었습니다. 많은 매출을 가져다주었죠. 그 과정에서 서비스는 초당 1000reqps가 넘는 경우가 종종 생겼습니다. 하루에 5~6번씩은 1000reqps가 넘었죠. 평균적으로도 500reqps가 넘는 요청이 몰렸습니다. 우리는 더 많은 성능이 필요했습니다.

(TBD)
